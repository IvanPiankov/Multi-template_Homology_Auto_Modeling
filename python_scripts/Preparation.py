import sys
import os


def find_path_to_dependency(directory, dependency, inside_check):
    """
    Defines the location of directory with dependency software (needed in case if the dependency is not a library)
    User must provide a name of file or directory inside the sought directory as additional verification
    In case of several directories satisfying the conditions function requires user to select one
    Also generates/open file 'paths' in working directory, where writes down the found path
    Returns one path to dependency software directory or None, if nothing is found

    :param directory: working directory
    :type directory: str
    :param dependency: name of the sought directory
    :type dependency: str
    :param inside_check: name of file of directory inside the sought directory
    :type inside_check: str
    :return: path to the sought directory
    :rtype: str
    """

    paths = []
    for root, dirs, files in os.walk('/'):
        if dependency in dirs:
            for in_root, in_dirs, in_files in os.walk(root + '/' + dependency):
                if inside_check in in_files or inside_check in in_dirs:
                    paths.append(in_root + '/')

    if len(paths) == 1:
        with open(directory + 'paths', 'a') as output:
            output.write(paths[0] + '\n')
        return paths[0]
    elif len(paths) == 0:
        print('You need to download this dependency')
        return None
    else:
        return input(f'You have more than one directory with the dependency. \nChoose one of them {paths}: ')


def general_questions():
    """
    Dialogue function, that asks user general parameters for script execution \n

    :return: tuple (id_protein, directory)
        WHERE
        str id_protein is id of target protein
        str directory is path to working directory
    """

    id_protein = input('Target protein UniProt ID (Ex:Q86WT6): ')
    directory = input('Working directory (Ex:path/to/save/folder/): ')
    return id_protein, directory


def questions_about_protein_databases():
    """
    Dialogue function, that asks user parameters for downloading protein databases \n

    :return: tuple (path_to_db, only_swiss_model, only_wwpdb_model, clean_pdb_db)
        WHERE
        str path_to_db is path to database if it already exists (None, if doesn't)
        bool only_swiss_model is flag that indicates that only Swiss-Model database is needed
        bool only_wwpdb_model is flag that indicates that only wwPDB database is needed
        bool clean_pdb_db is flag that indicates whether to remove duplicates generated by homologous chains from
            wwPDB database
    """

    only_swiss_model = False
    only_wwpdb_model = False
    clean_pdb_db = False
    if input("Do you have a protein database created by this script earlier? [Y/N]:") in ["y", "Y"]:
        path_to_db = input("Path to this database (Ex:path/to/database/database): ")
    else:
        path_to_db = None
        if input("Download both Swiss-Model and wwPDB databases? [Y/N]:") in ["n", "N"]:
            if input("Download only Swiss-Model database? [Y/N]:") in ["y", "Y"]:
                only_swiss_model = True
            else:
                only_wwpdb_model = True
                if input("Do you want to clean wwPDB from duplicates? (recommended) [Y/N]:") in ["y", "Y"]:
                    clean_pdb_db = True
    return path_to_db, only_swiss_model, only_wwpdb_model, clean_pdb_db


def questions_about_homologs_search():
    """
    Dialogue function, that asks user parameters for homologues search \n

    :return: tuple (n_of_homologs, e_value_threshold)
        WHERE
        int n_of_homologs is a number of homologues that mafft-homologs will find
        int e_value_threshold is e-value threshold for homology search by mafft-homologs
    """
    n_of_homologs = input('Number homologues (Ex:30):')
    try:
        n_of_homologs = int(n_of_homologs)
    except ValueError:
        print('Number of homologues must be an integer. Will set it as 30')
        n_of_homologs = 30

    e_value_threshold = input('E-value threshold for homologues search (Ex:35): ')
    try:
        e_value_threshold = int(e_value_threshold)
    except ValueError:
        print('E-value must be an integer. Will set it as 35')
        e_value_threshold = 35

    return n_of_homologs, e_value_threshold


def questions_about_homologs_processing_and_modeling():
    """
    Dialogue function, that asks user parameters for modeling part execution \n

    :return: tuple (identity_threshold, coverage_threshold, desired_number_of_models)
        WHERE
        float identity_threshold is threshold for homologs identity percent
        float coverage_threshold is threshold for target coverage
        int desired_number_of_models is desired number of models
    """

    identity_threshold = input(
        'Provide the identity threshold (Ex: 15). Templates with identity below threshold will be removed. ')
    try:
        identity_threshold = float(identity_threshold)
    except ValueError:
        print('Identity threshold must be a digit. Will set it as 15%')
        identity_threshold = 15

    coverage_threshold = input(
        'What will be the threshold for minimal coverage % of target sequence by templates? (Ex: 60)'
        ' In case of insufficient coverage, the script execution will be aborted: ')
    try:
        coverage_threshold = float(coverage_threshold)
    except ValueError:
        print('Coverage threshold must be a digit. Will set it as 60%')
        coverage_threshold = 60

    desired_number_of_models = input('How many models do you want? ')
    try:
        desired_number_of_models = int(desired_number_of_models)
    except ValueError:
        print('Number of models must be an integer. Will set it as 5')
        desired_number_of_models = 5

    return identity_threshold, coverage_threshold, desired_number_of_models


def questions_about_scoring():
    """
    Dialogue function, that asks user parameters for scoring part execution \n

    :return: tuple (mean_and_sd_for_function, graph_for_function)
        WHERE
        bool mean_and_sd_for_function is flag that indicates whether to count mean and sd of score
        bool graph_for_function is flag that indicates whether to generate graph with score distribution across target length
    """

    mean_and_sd_for_function = True
    graph_for_function = True
    if input("Do you want to calculate the mean and SD for the resulting models' score? [Y/N]:") in ["n", "N"]:
        mean_and_sd_for_function = False
    if input("Do you want to plot with the a quality score for the residuals ? [Y/N]:") in ["n", "N"]:
        graph_for_function = False
    return mean_and_sd_for_function, graph_for_function
